'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

// Gets value from localstorage
function getValueFromLocalStorage(key) {
    var _a;
    if (typeof localStorage === "undefined") {
        return null;
    }
    const storedValue = (_a = localStorage.getItem(key)) !== null && _a !== void 0 ? _a : "null";
    try {
        return JSON.parse(storedValue);
    }
    catch (error) {
        console.error(error);
    }
    return storedValue;
}
// Saves value to localstorage
function saveValueToLocalStorage(key, value) {
    if (typeof localStorage === "undefined") {
        return null;
    }
    return localStorage.setItem(key, JSON.stringify(value));
}
/**
 * @param key Key of the localStorage object
 * @param initialState Default initial value
 */
function initialize(key, initialState) {
    const valueLoadedFromLocalStorage = getValueFromLocalStorage(key);
    if (valueLoadedFromLocalStorage === null) {
        return initialState;
    }
    else {
        return valueLoadedFromLocalStorage;
    }
}
/**
 * useLocalstorageState hook
 * Tracks a value within localStorage and updates it
 *
 * @param {string} key - Key of the localStorage object
 * @param {any} initialState - Default initial value
 * @see https://rooks.vercel.app/docs/useLocalstorageState
 */
function useLocalstorageState(key, initialState) {
    const [value, setValue] = react.useState(() => initialize(key, initialState));
    const isUpdateFromCrossDocumentListener = react.useRef(false);
    const isUpdateFromWithinDocumentListener = react.useRef(false);
    const customEventTypeName = react.useMemo(() => {
        return `rooks-${key}-localstorage-update`;
    }, [key]);
    react.useEffect(() => {
        /**
         * We need to ensure there is no loop of
         * storage events fired. Hence we are using a ref
         * to keep track of whether setValue is from another
         * storage event
         */
        if (!isUpdateFromCrossDocumentListener.current ||
            !isUpdateFromWithinDocumentListener.current) {
            saveValueToLocalStorage(key, value);
        }
    }, [key, value]);
    const listenToCrossDocumentStorageEvents = react.useCallback((event) => {
        var _a;
        if (event.storageArea === localStorage && event.key === key) {
            try {
                isUpdateFromCrossDocumentListener.current = true;
                const newValue = JSON.parse((_a = event.newValue) !== null && _a !== void 0 ? _a : "null");
                if (value !== newValue) {
                    setValue(newValue);
                }
            }
            catch (error) {
                console.log(error);
            }
        }
    }, [key, value]);
    // check for changes across documents
    react.useEffect(() => {
        // eslint-disable-next-line no-negated-condition
        if (typeof window !== "undefined") {
            window.addEventListener("storage", listenToCrossDocumentStorageEvents);
            return () => {
                window.removeEventListener("storage", listenToCrossDocumentStorageEvents);
            };
        }
        else {
            console.warn("useLocalstorageState: window is undefined.");
            return () => { };
        }
    }, [listenToCrossDocumentStorageEvents]);
    const listenToCustomEventWithinDocument = react.useCallback((event) => {
        try {
            isUpdateFromWithinDocumentListener.current = true;
            const { newValue } = event.detail;
            if (value !== newValue) {
                setValue(newValue);
            }
        }
        catch (error) {
            console.log(error);
        }
    }, [value]);
    // check for changes within document
    react.useEffect(() => {
        // eslint-disable-next-line no-negated-condition
        if (typeof document !== "undefined") {
            document.addEventListener(customEventTypeName, listenToCustomEventWithinDocument);
            return () => {
                document.removeEventListener(customEventTypeName, listenToCustomEventWithinDocument);
            };
        }
        else {
            console.warn("[useLocalstorageState] document is undefined.");
            return () => { };
        }
    }, [customEventTypeName, listenToCustomEventWithinDocument]);
    const broadcastValueWithinDocument = react.useCallback((newValue) => {
        // eslint-disable-next-line no-negated-condition
        if (typeof document !== "undefined") {
            const event = new CustomEvent(customEventTypeName, { detail: { newValue } });
            document.dispatchEvent(event);
        }
        else {
            console.warn("[useLocalstorageState] document is undefined.");
        }
    }, [customEventTypeName]);
    const set = react.useCallback((newValue) => {
        isUpdateFromCrossDocumentListener.current = false;
        isUpdateFromWithinDocumentListener.current = false;
        setValue(newValue);
        broadcastValueWithinDocument(newValue);
    }, [broadcastValueWithinDocument]);
    const remove = react.useCallback(() => {
        localStorage.removeItem(key);
    }, [key]);
    return [value, set, remove];
}

exports.useLocalstorageState = useLocalstorageState;
