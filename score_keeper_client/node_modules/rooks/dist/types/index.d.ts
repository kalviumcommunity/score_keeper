import React, { DependencyList, MutableRefObject, Ref, Dispatch, SetStateAction, LegacyRef, RefObject, RefCallback, ChangeEvent, useEffect, Reducer, ReducerWithoutAction, DispatchWithoutAction } from 'react';
import { DebounceSettings, DebouncedFunc } from 'lodash';
import { FocusEvents, DOMAttributes } from '@react-types/shared';

declare type Push<T> = (...args: Parameters<Array<T>["push"]>) => void;
declare type Pop = () => void;
declare type Unshift<T> = (...args: Parameters<Array<T>["unshift"]>) => void;
declare type Shift = () => void;
declare type Reverse = () => void;
declare type Concat<T> = (value: T[]) => void;
declare type Fill<T> = (value: T, start?: number, end?: number) => void;
declare type UpdateItemAtIndex<T> = (index: number, value: T) => void;
declare type Clear = () => void;
declare type SetArray<T> = (value: T[]) => void;
declare type Splice<T> = (...args: Parameters<Array<T>["splice"]>) => void;
declare type RemoveItemAtIndex = (index: number) => void;
declare type ReplaceItemAtIndex<T> = (index: number, value: T) => void;
declare type InsertItemAtIndex<T> = (index: number, value: T) => void;
declare type Sort<T> = (compareFn?: (a: T, b: T) => number) => void;
declare type UseArrayStateControls<T> = {
    push: Push<T>;
    pop: Pop;
    clear: Clear;
    unshift: Unshift<T>;
    shift: Shift;
    reverse: Reverse;
    concat: Concat<T>;
    fill: Fill<T>;
    updateItemAtIndex: UpdateItemAtIndex<T>;
    setArray: SetArray<T>;
    splice: Splice<T>;
    removeItemAtIndex: RemoveItemAtIndex;
    replaceItemAtIndex: ReplaceItemAtIndex<T>;
    insertItemAtIndex: InsertItemAtIndex<T>;
    sort: Sort<T>;
};
declare type UseArrayStateReturnValue<T> = [T[], UseArrayStateControls<T>];
/**
 * useArrayState
 * @description Array state manager hook for React
 * @param {Array<T>} initialState Initial state of the array
 * @returns {UseArrayStateReturnValue<T>} Array state manager hook for React
 * @see {@link https://rooks.vercel.app/docs/useArrayState}
 *
 * @example
 *
 * const [array, controls] = useArrayState([1, 2, 3]);
 *
 * controls.push(4); // [1, 2, 3, 4]
 * controls.pop(); // [1, 2, 3]
 * controls.unshift(0); // [0, 1, 2, 3]
 * controls.shift(); // [1, 2, 3]
 * controls.reverse(); // [3, 2, 1]
 * controls.concat([4, 5, 6]); // [3, 2, 1, 4, 5, 6]
 * controls.fill(0); // [0, 0, 0, 0, 0, 0]
 * controls.updateItemAtIndex(0, 1); // [1, 0, 0, 0, 0, 0]
 * controls.clear(); // []
 * controls.setArray([1, 2, 3]); // [1, 2, 3]
 * controls.splice(1, 1); // [1, 3]
 * controls.removeItemAtIndex(1); // [1]
 * controls.replaceItemAtIndex(0, 2); // [2]
 * controls.insertItemAtIndex(0, 1); // [1, 2]
 * controls.sort((a, b) => a - b); // [1, 2]
 *
 */
declare function useArrayState<T>(initialArray?: T[]): UseArrayStateReturnValue<T>;

declare type Effect<T> = (shouldContinueEffect: () => boolean) => Promise<T>;
declare type CleanupFunction<T> = (result: T | void) => void;
/**
 * A version of useEffect that accepts an async function
 *
 * @param {Effect<T>} effect Async function that can return a cleanup function and takes in an AbortSignal
 * @param {DependencyList} deps If present, effect will only activate if the values in the list change
 * @param {CleanupFunction} cleanup The destroy/cleanup function. Will be called with previous result if it exists.
 * @see https://rooks.vercel.app/docs/useAsyncEffect
 * @example
 * ```jsx
 * useAsyncEffect(
        async (shouldContinueEffect) => {
          const data1 = await fetchData1(arg1, arg2);
          if(shouldContinueEffect()) {
            const data2 = await fetchData2(arg1, arg2);
          }
          ...
        },
        [arg1, arg2],
        (previousResult) => {
          // ... do something with previousResult ...
        }
      );
 * ```
 */
declare function useAsyncEffect<T>(effect: Effect<T>, deps: DependencyList, cleanup?: CleanupFunction<T>): void;

/**
 * useBoundingclientRect hook
 *
 * @param ref The React ref whose ClientRect is needed
 * @returns DOMRect | null
 * @see https://rooks.vercel.app/docs/useBoundingclientRect
 */
declare function useBoundingclientrect(ref: MutableRefObject<HTMLElement | null>): DOMRect | null;

declare type HTMLElementOrNull = HTMLElement | null;
declare type RefElementOrNull<T> = T | null;
declare type CallbackRef<T extends HTMLElement | null = HTMLElementOrNull> = (node: T) => void;
declare type PossibleRef<T> = Ref<T> | undefined;

/**
 * useBoundingclientrectRef hook
 * Tracks the boundingclientrect of a React Ref and fires a callback when the element's size changes.
 *
 * @returns [CallbackRef | null, DOMRect | null, () => void]
 * @see https://rooks.vercel.app/docs/useBoundingclientRectRef
 */
declare function useBoundingclientrectRef(): [
    CallbackRef | null,
    DOMRect | null,
    () => void
];

declare type CountdownOptions = {
    interval?: number;
    onDown?: (restTime: number, newTime: Date) => void;
    onEnd?: (newTime: Date) => void;
};
/**
 *
 * useCountdown
 * Easy way to countdown until a given endtime in intervals
 *
 * @param endTime Time to countdown
 * @param options  Countdown options
 * @see https://rooks.vercel.app/docs/useCountdown
 */
declare function useCountdown(endTime: Date, options?: CountdownOptions): number;

declare type CounterHandler = {
    decrement: () => void;
    decrementBy: (amount: number) => void;
    increment: () => void;
    incrementBy: (amount: number) => void;
    reset: () => void;
    value: number;
};
/**
 *
 * @typedef handler
 * @type {object}
 * @property {number} value The value of the counter
 * @property {Function}  increment Increment counter value by 1
 * @property {Function} decrement Decrement counter value by 1
 * @property {Function} incrementBy Increment counter by incrAmount
 * @property {Function} decrementBy Decrement counter by decrAmount
 * @property {Function} reset Reset counter to initialValue
 * @see {@link https://rooks.vercel.app/docs/useCounter}
 */
/**
 * Counter hook
 *
 * @param {number} initialValue The initial value of the counter
 * @returns {handler} A handler to interact with the counter
 * @see https://rooks.vercel.app/docs/useCounter
 */
declare function useCounter(initialValue: number): CounterHandler;

declare type DeepNullable<T> = {
    [K in keyof T]: DeepNullable<T[K]> | null;
};
declare type ListenerOptions = boolean | {
    capture?: boolean;
    once?: boolean;
    passive?: boolean;
    signal?: AbortSignal;
};
declare type AnyFunction = (...args: any[]) => any;
declare type ExcludeFunction<T> = Exclude<T, AnyFunction>;

/**
 * Debounce hook
 * Debounces a function
 *
 * @param callback The callback to debounce
 * @param wait The duration to debounce
 * @param options The options object.
 * @param options.leading Specify invoking on the leading edge of the timeout.
 * @param options.maxWait The maximum time func is allowed to be delayed before itâ€™s invoked.
 * @param options.trailing Specify invoking on the trailing edge of the timeout.
 * @returns Returns the new debounced function.
 * @see https://rooks.vercel.app/docs/useDebounce
 */
declare function useDebounce<T extends AnyFunction>(callback: T, wait?: number, options?: DebounceSettings): DebouncedFunc<T>;

declare type UseDebouncedValueReturnType<TValue = unknown, TInitializeWithNull extends boolean = false> = [
    debouncedValue: TInitializeWithNull extends true ? TValue | null : TValue,
    immediatelyUpdateDebouncedValue: Dispatch<SetStateAction<TInitializeWithNull extends true ? TValue | null : TValue>>
];
/**
 * useDebouncedValue
 * @param value The value to debounce
 * @param timeout The duration to debounce
 * @param options The options object.
 * @see https://rooks.vercel.app/docs/useDebouncedValue
 */
declare const useDebouncedValue: <TValue = unknown, TInitializeWithNull extends boolean = false>(value: TValue, timeout: number, options?: Partial<{
    initializeWithNull: TInitializeWithNull;
}>) => UseDebouncedValueReturnType<TValue, TInitializeWithNull>;

declare type UseUndoStateOptions = {
    maxSize: number;
};
declare type UseUndoStatePushFunctionArgumentsCallback<T> = (currentValue: T) => T;
declare type UseUndoStatePushFunction<T> = (argument: T | UseUndoStatePushFunctionArgumentsCallback<T>) => void;
declare type UndoFunction = () => void;
declare type UseUndoStateReturnValue<T> = [
    ExcludeFunction<T>,
    UseUndoStatePushFunction<ExcludeFunction<T>>,
    UndoFunction
];
declare type CallbackWithNoArguments = () => void;
declare type UseGeolocationReturnType = {
    isError: boolean;
    lat?: number;
    lng?: number;
    message: string;
};

/**
 * useDidMount hook
 * @description Calls a function on mount
 *
 * @param {Function} callback Callback function to be called on mount
 * @see https://rooks.vercel.app/docs/useDidMount
 */
declare function useDidMount(callback: CallbackWithNoArguments): void;

/**
 *  useDidUpdate hook
 *
 *  Fires a callback on component update
 *  Can take in a list of conditions to fire callback when one of the
 *  conditions changes
 *
 * @param {Function} callback The callback to be called on update
 * @param {Array} conditions The list of variables which trigger update when they are changed
 * @see https://rooks.vercel.app/docs/useDidUpdate
 */
declare function useDidUpdate(callback: () => void, conditions?: unknown[]): void;

declare type UseDimensionsRefReturn = {
    bottom: number;
    height: number;
    left: number;
    right: number;
    top: number;
    width: number;
    x: number;
    y: number;
} | null;
declare type UseDimensionsHook = [
    LegacyRef<HTMLDivElement> | undefined,
    UseDimensionsRefReturn,
    HTMLElement | null
];
declare type UseDimensionsRefArgs = {
    updateOnResize?: boolean;
    updateOnScroll?: boolean;
};
/**
 * useDimensionsRef
 * @param updateOnScroll Whether to update on scroll
 * @param updateOnResize Whether to update on resize
 * @returns [React.Ref<HTMLDivElement>, UseDimensionsRefReturn, HTMLElement | null]
 * @see https://rooks.vercel.app/docs/useDimensionsRef
 */
declare const useDimensionsRef: ({ updateOnScroll, updateOnResize, }?: UseDimensionsRefArgs) => UseDimensionsHook;

/**
 *  useDocumentEventListener hook
 *
 * @description A react hook to an event listener to the document
 *
 * @param {keyof DocumentEventMap} eventName The event to track
 * @param {Function} callback The callback to be called on event
 * @param {ListenerOptions} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useDocumentEventListener
 */
declare function useDocumentEventListener(eventName: keyof DocumentEventMap, callback: (...args: unknown[]) => void, listenerOptions?: ListenerOptions, isLayoutEffect?: boolean): void;

declare type UseDocumentVisibilityStateReturnType = Document["visibilityState"] | null;
/**
 * useDocumentVisibilityState
 * @description Returns the visibility state of the document. Returns null on the server side.
 * @returns {UseDocumentVisibilityStateReturnType} The visibility state of the document. `null` on the server.
 * @see {@link https://rooks.vercel.app/docs/useDocumentVisibilityState}
 */
declare function useDocumentVisibilityState(): UseDocumentVisibilityStateReturnType;

/**
 * useEffectOnceWhen hook
 *
 * @description It fires a callback once when a condition is true or become true.
 * Fires the callback at most one time.
 *
 * @param callback The callback to fire
 * @param when The condition which needs to be true
 * @see https://rooks.vercel.app/docs/useEffectOnceWhen
 */
declare function useEffectOnceWhen(callback: () => void, when?: boolean): void;

/**
 *  useEventListenerRef hook
 *
 *  A react hook to an event listener to an element
 *  Returns a ref
 *
 * @param {string} eventName The event to track`
 * @param {Function} callback The callback to be called on event
 * @param {object} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @returns {Function} A callback ref that can be used as ref prop
 * @see https://rooks.vercel.app/docs/useEventListenerRef
 */
declare function useEventListenerRef(eventName: string, callback: (...args: unknown[]) => void, listenerOptions?: AddEventListenerOptions | EventListenerOptions | boolean, isLayoutEffect?: boolean): (refElement: RefElementOrNull<HTMLElement>) => void;

/**
 * useFreshRef
 *
 * @param value The value which needs to be fresh at all times. Probably
 * best used with functions
 * @param preferLayoutEffect Should the value be updated using a layout effect
 * or a passive effect. Defaults to false.
 * @returns A ref containing the fresh value
 * @see https://rooks.vercel.app/docs/useFreshRef
 */
declare function useFreshRef<T>(value: T, preferLayoutEffect?: boolean): MutableRefObject<T>;

declare type CallbackType<T> = (...args: T[]) => void;
/**
 * useFreshTick
 * @param callback The callback to be called on mount
 * @returns A fresh callback.
 * @see https://rooks.vercel.app/docs/useFreshCallback
 */
declare function useFreshTick<T>(callback: CallbackType<T>): CallbackType<T>;

interface UseFullscreenProps {
    target?: RefObject<Element>;
    onChange?: (event: Event) => void;
    onError?: (event: Event) => void;
    requestFullScreenOptions?: FullscreenOptions;
}
/**
 *
 * useFullscreen hook
 *
 * Gives control to make HTML Elements fullscreen.
 *
 * @param {Element | undefined} props.target The target element to be fullscreen.
 * @param {(event: Event) => void} props.onChange The function to be called when the fullscreen changes.
 * @param {(event: Event) => void} props.onError The function to be called when the fullscreen error occurs.
 * @param {FullscreenOptions} props.requestFullscreenOptions The options to be passed to the requestFullscreen function.
 * @return {Object} returns - The controlls of useFullscreen hook.
 * @return {boolean} returns.isFullscreenAvailable - Whether the fullscreen is available.
 * @return {Element | null} returns.fullscreenElement - The fullscreen element.
 * @return {boolean} returns.isFullscreenEnabled - Whether the fullscreen is enabled.
 * @return {() => Promise<void>} returns.enableFullscreen - The function to enable fullscreen.
 * @return {() => Promise<void>} returns.disableFullscreen - The function to disable fullscreen.
 * @return {() => Promise<void>} returns.toggleFullscreen - The function to toggle fullscreen.
 */
declare function useFullscreen(props?: UseFullscreenProps): {
    isFullscreenAvailable: boolean;
    fullscreenElement: Element | null;
    isFullscreenEnabled: boolean;
    enableFullscreen: () => Promise<void>;
    disableFullscreen: () => Promise<void>;
    toggleFullscreen: () => Promise<void>;
};

declare type FocusProps = FocusEvents;
interface FocusResult<T> {
    /** Props to spread onto the target element. */
    focusProps: DOMAttributes<T>;
}
/**
 * useFocus
 * @description Handles focus events for the immediate target element.
 * @see {@link https://rooks.vercel.app/docs/useFocus}
 */
declare const useFocus: <T extends HTMLElement>(props: FocusProps) => FocusResult<T>;

interface FocusWithinProps {
    /** Handler that is called when the target element or a descendant receives focus. */
    onFocusWithin?: (e: React.FocusEvent) => void;
    /** Handler that is called when the target element and all descendants lose focus. */
    onBlurWithin?: (e: React.FocusEvent) => void;
    /** Handler that is called when the the focus within state changes. */
    onFocusWithinChange?: (isFocusWithin: boolean) => void;
}
interface FocusWithinResult<T> {
    /** Props to spread onto the target element. */
    focusWithinProps: DOMAttributes<T>;
}
/**
 * useFocusWithin
 * @description Handles focus events for the target component.
 * @see {@link https://rooks.vercel.app/docs/useFocusWithin}
 */
declare const useFocusWithin: <T extends HTMLElement>(props: FocusWithinProps) => FocusWithinResult<T>;

/**
 * useForkRef
 * Joins refs together and returns a combination of the two as a new ref
 *
 * @param refA
 * @param refB
 * @returns MutableRefObject
 * @see https://rooks.vercel.app/docs/useForkRef
 */
declare function useForkRef<T>(refA: PossibleRef<T> | null, refB: PossibleRef<T> | null): RefCallback<T> | null;

declare type UseGetIsMounted = () => () => boolean;
/**
 * @description useGetIsMounted hook checks if a component is mounted or not at the time.
 * Useful for async effects. Returns a callback that returns a boolean representing if the component
 * is mounted at the time.
 * @returns () => boolean
 * @see https://rooks.vercel.app/docs/useGetIsMounted
 */
declare const useGetIsMounted: UseGetIsMounted;

declare type UseGeoLocationOptions = PositionOptions & {
    when?: boolean;
};
/**
 * useGeolocation
 * Gets the geolocation data as a hook
 *
 * @param {UseGeoLocationOptions} geoLocationOptions Geolocation options
 * @see {@link https://rooks.vercel.app/docs/useGeolocation}
 */
declare const useGeolocation: (geoLocationOptions?: UseGeoLocationOptions) => UseGeolocationReturnType | null;

declare type InputChangeEvent = ChangeEvent<HTMLInputElement>;
declare type InputHandler<T> = {
    /**
     * Function to handle onChange of an input element
     *
     * @param event The input change event
     */
    onChange: (event: InputChangeEvent) => void;
    /**
     * The current value of the input
     */
    value: T;
};
declare type Options$4<T> = {
    /**
     * validate
     *
     * Validator function which can be used to prevent updates
     *
     * @param {any} New value
     * @param {any} Current value
     * @returns {boolean} Whether an update should happen or not
     */
    validate?: (newValue: T, currentValue: T) => boolean;
};
/**
 *
 * useInput Hook
 *
 * Handles an input's value and onChange props internally to
 * make text input creation process easier
 *
 * @param {unknown} [initialValue] Initial value of the input
 * @param {Options} [options] Options object
 * @returns {InputHandler} Input handler with value and onChange
 * @see https://rooks.vercel.app/docs/useInput
 */
declare function useInput<T extends number | string | readonly string[] | undefined = string>(initialValue?: T, options?: Options$4<T>): InputHandler<T>;

/**
 * A setInterval hook that calls a callback after a interval duration
 * when a condition is true
 *
 * @param callback The callback to be invoked after interval
 * @param intervalDurationMs Amount of time in ms after which to invoke
 * @param when The condition which when true, sets the interval
 * @param startImmediate If the callback should be invoked immediately
 * @see https://rooks.vercel.app/docs/useIntervalWhen
 */
declare function useIntervalWhen(callback: () => void, intervalDurationMs?: number, when?: boolean, startImmediate?: boolean): void;

/**
 *
 * useIntersectionObserverRef hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation
 * @param {IntersectionObserverInit} options
 * @see https://rooks.vercel.app/docs/useIntersectionObserverRef
 */
declare function useIntersectionObserverRef(callback: IntersectionObserverCallback | undefined, options?: IntersectionObserverInit): [CallbackRef];

/**
 *
 * useInViewRef hook
 *
 * Returns a mutation observer for a React Ref and true/false when element enters/leaves the viewport. Also fires a callback.
 *
 * @param {IntersectionObserverCallback} callback Function that needs to be fired on mutation
 * @param {IntersectionObserverInit} options
 * @see https://rooks.vercel.app/docs/useInViewRef
 */
declare function useInViewRef(callback?: IntersectionObserverCallback, options?: IntersectionObserverInit): [CallbackRef, boolean];

/**
 * useIsomorphicEffect
 * Resolves to useEffect when "window" is not in scope and useLayout effect in the browser
 *
 * @param {Function} callback Callback function to be called on mount
 * @see https://rooks.vercel.app/docs/useIsomorphicEffect
 */
declare const useIsomorphicEffect: typeof useEffect;

declare type TrackedKeyEvents$2 = "keydown" | "keypress" | "keyup";
declare type Options$3 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents$2[];
    /**
     * target mutable ref on which the events should be listened. Doesn't work with callback refs.
     * Please use useKeyRef instead if you want to use with callback refs.
     * If no target is specified, events are listened to on the window. Defaults to window.
     */
    target?: RefObject<HTMLElement>;
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
/**
 * useKey hook
 *
 * Fires a callback on keyboard events like keyDown, keyPress and keyUp
 *
 * @param {TrackedKeyEvents} keys List of keys to listen for. Eg: ["a", "b"]
 * @param {Callback} callback  Callback to fire on keyboard events
 * @param {Options} options Options
 * @see https://rooks.vercel.app/docs/useKey
 */
declare function useKey(keys: Array<number | string> | number | string, callback: (event: KeyboardEvent) => void, options?: Options$3): void;

declare type TrackedKeyEvents$1 = "keydown" | "keypress" | "keyup";
declare type Options$2 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents$1[];
    /**
     * target ref on which the events should be listened. If no target is specified,
     * events are listened to on the window. Only works with object refs. If you want to use with callback refs,
     * please use useKeyRef instead.
     */
    target?: RefObject<HTMLElement>;
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
declare type KeyBindings = {
    [key: string]: (event: KeyboardEvent) => void;
};
/**
 * useKeyBindings
 *
 * useKeyBindings binds pairs of keyboard events and handlers
 *
 * @param { KeyBindings } keyBindings
 * @param {Options} options
 * @see https://rooks.vercel.app/docs/useKeyBindings
 */
declare const useKeyBindings: (keyBindings: KeyBindings, options?: Options$2) => void;

declare type TrackedKeyEvents = "keydown" | "keypress" | "keyup";
declare type Callback$2 = (event: KeyboardEvent) => void;
declare type Options$1 = {
    /**
     * Keyboardevent types to listen for. Valid options are keyDown, keyPress and keyUp
     */
    eventTypes?: TrackedKeyEvents[];
    /**
     * Condition which if true, will enable the event listeners
     */
    when?: boolean;
};
/**
 * useKeyRef hook
 *
 * Fires a callback on keyboard events like keyDown, keyPress and keyUp
 *
 * @param {[string|number]} keys List of keys to listen for. Eg: ["a", "b"]
 * @param {Function} callback Callback to fire on keyboard events
 * @param {Options} options Options
 * @returns {CallbackRef} CallbackRef
 * @see https://rooks.vercel.app/docs/useKeyRef
 */
declare function useKeyRef(keys: Array<number | string> | number | string, callback: Callback$2, options?: Options$1): CallbackRef;

declare type Options = {
    /**
     * should the event logging be continuous
     */
    continuous?: boolean;
    /**
     * target ref on which the events should be listened. If no target is specified,
     * events are listened to on the document
     */
    target?: MutableRefObject<Document> | MutableRefObject<HTMLElement | null | undefined>;
    /**
     * when boolean to enable and disable events, when passed false
     * remove the eventlistener if any
     */
    when?: boolean;
    /**
     * opt-in to prevent alert, confirm and prompt from causing the eventlistener to lose track of keyup events.
     */
    preventLostKeyup?: boolean;
};
/**
 * useKeys hook
 *
 * @param keysList - list of keys to listen to
 * @param callback  - callback to be called when a key is pressed
 * @param options - options to be passed to the event listener
 * @see https://rooks.vercel.app/docs/useKeys
 */
declare function useKeys(keysList: string[], callback: (event: KeyboardEvent) => void, options?: Options): void;

/**
 * useLifecycleLogger hook
 * logs parameters as component transitions through lifecycles
 *
 * @param componentName Name of the component
 * @param {...*} otherArgs Other arguments to log
 * @see https://rooks.vercel.app/docs/useLifecycleLogger
 */
declare const useLifecycleLogger: (componentName?: string, ...otherArgs: unknown[]) => void;

declare type UseLocalstorageStateReturnValue<S> = [
    S,
    Dispatch<SetStateAction<S>>,
    () => void
];
/**
 * useLocalstorageState hook
 * Tracks a value within localStorage and updates it
 *
 * @param {string} key - Key of the localStorage object
 * @param {any} initialState - Default initial value
 * @see https://rooks.vercel.app/docs/useLocalstorageState
 */
declare function useLocalstorageState<S>(key: string, initialState?: S | (() => S)): UseLocalstorageStateReturnValue<S>;

/**
 * useMapState hook
 * A hook to manage state in the form of a map or object.
 *
 * @param initialValue Initial value of the map
 * @see https://rooks.vercel.app/docs/useMapState
 */
declare function useMapState<T extends {
    [key: string]: unknown;
}, K extends keyof T>(initialValue: T): [
    T,
    {
        has: (key: K) => boolean;
        remove: (key: K) => void;
        removeAll: () => void;
        removeMultiple: (...keys: K[]) => void;
        set: (key: K, value: T[K]) => void;
        setMultiple: (next: Partial<T>) => void;
    }
];

/**
 * useMediaMatch
 *
 * A react hook that signals whether or not a media query is matched.
 *
 * @param query The media query to signal on. Example, `"print"` will signal
 * `true` when previewing in print mode, and `false` otherwise.
 * @returns Whether or not the media query is currently matched.
 * @see https://rooks.vercel.app/docs/useMediaMatch
 */
declare function useMediaMatch(query: string): boolean;

/**
 * useMergeRefs
 * Merges multiple refs into a single function ref.
 * Takes any number of refs.
 * Refs can be mutable refs or function refs.
 *
 * @param refs
 * @see https://rooks.vercel.app/docs/useMergeRefs
 */
declare function useMergeRefs<T>(...refs: Array<PossibleRef<T>>): RefCallback<T> | null;

declare type MouseData = {
    clientX: number | null;
    clientY: number | null;
    movementX: number | null;
    movementY: number | null;
    offsetX: number | null;
    offsetY: number | null;
    pageX: number | null;
    pageY: number | null;
    screenX: number | null;
    screenY: number | null;
    x: number | null;
    y: number | null;
};
/**
 * useMouse hook
 *
 * Retrieves current mouse position and information about the position like
 * screenX, pageX, clientX, movementX, offsetX
 * @see https://rooks.vercel.app/docs/useMouse
 */
declare function useMouse(): MouseData;

declare type OptionalIndexValue<T> = {
    index?: number;
    value?: T;
};
declare type OptionalIndicesValues<T> = {
    indices?: number[];
    values?: T[];
};

declare type UseMultiSelectableListReturnType<T> = [
    Array<number[] | T[]>,
    {
        matchSelection: (parameters: OptionalIndexValue<T>) => boolean;
        toggleSelection: (parameters: OptionalIndexValue<T>) => () => void;
        updateSelections: ({ indices, values, }: OptionalIndicesValues<T>) => () => void;
    }
];
/**
 * useMultiSelectableList
 * A custom hook to easily select multiple values from a list
 *
 * @param list - The list of values to select from
 * @param initialSelectIndices - The indices of the initial selections
 * @param allowUnselected - Whether or not to allow unselected values
 * @see https://rooks.vercel.app/docs/useMultiSelectableList
 */
declare function useMultiSelectableList<T>(list?: T[], initialSelectIndices?: number[], allowUnselected?: boolean): UseMultiSelectableListReturnType<T>;

/**
 *
 * useMutationObserver hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {MutableRefObject<HTMLElement | null>} ref React ref on which mutations are to be observed
 * @param {MutationCallback} callback Function that needs to be fired on mutation
 * @param {MutationObserverInit} options
 * @see https://rooks.vercel.app/docs/useMutationObserver
 */
declare function useMutationObserver(ref: MutableRefObject<HTMLElement | null>, callback: MutationCallback, options?: MutationObserverInit): void;

/**
 *
 * useMutationObserverRef hook
 *
 * Returns a mutation observer for a React Ref and fires a callback
 *
 * @param {MutationCallback} callback Function that needs to be fired on mutation
 * @param {MutationObserverInit} options
 * @see https://rooks.vercel.app/docs/useMutationObserverRef
 */
declare function useMutationObserverRef(callback: MutationCallback, options?: MutationObserverInit): [CallbackRef];

declare type Language = string | null;
/**
 * useNavigatorLanguage hook
 * Returns the language of the navigator
 *
 * @returns {Language}
 * @see https://rooks.vercel.app/docs/useNavigatorLanguage
 */
declare function useNavigatorLanguage(): Language;

/**
 *
 * useOnWindowResize hook
 *
 * Fires a callback when window resizes
 *
 * @param {Function} callback Callback to be called before unmount
 * @param {boolean} when When the handler should be applied
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useOnWindowResize
 */
declare function useOnWindowResize(callback: EventListener, when?: boolean, isLayoutEffect?: boolean): void;

/**
 *
 * useOnWindowScroll hook
 * Fires a callback when window scroll
 *
 * @param {Function} callback Callback to be called before unmount
 * @param {boolean} when When the handler should be applied
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @see https://rooks.vercel.app/docs/useOnWindowScroll
 *
 */
declare function useOnWindowScroll(callback: EventListener, when?: boolean, isLayoutEffect?: boolean): void;

/**
 * useOnline hook
 *
 * Returns true if navigator is online, false if not.
 *
 * @returns {boolean} The value of navigator.onLine
 * @see https://rooks.vercel.app/docs/useOnline
 */
declare function useOnline(): boolean | null;

/**
 * useOutsideClick hook
 * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
 *
 * @param ref Ref whose outside click needs to be listened to
 * @param handler Callback to fire on outside click
 * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
 * @see https://rooks.vercel.app/docs/useOutsideClick
 * @example
 * ```tsx
 * import { useOutsideClick } from "@/hooks/useOutsideClick";
 * import { useRef } from "react";
 * import { noop } from "@/utils/noop";
 *
 * const MyComponent = () => {
 *  const ref = useRef<HTMLDivElement>(null);
 *  const [isOpen, setIsOpen] = useState(false);
 *    const handleOutsideClick = () => setIsOpen(false);
 *  useOutsideClick(ref, handleOutsideClick);
 *  return (
 *   <div ref={ref}>
 *    <button onClick={() => setIsOpen(true)}>Open</button>
 *   {isOpen && (
 *   <div>Inside</div>
 *   )}
 * </div>
 * );
 * }
 * ```
 */
declare function useOutsideClick(ref: MutableRefObject<HTMLElement | null>, handler: (event: MouseEvent) => void, when?: boolean): void;

/**
 * useOutsideClickRef hook
 * Checks if a click happened outside a Ref. Handy for dropdowns, modals and popups etc.
 *
 * @param handler Callback to fire on outside click
 * @param when A boolean which which activates the hook only when it is true. Useful for conditionally enable the outside click
 * @returns An array with first item being ref
 * @see https://rooks.vercel.app/docs/useOutsideClick
 */
declare function useOutsideClickRef(handler: (event: MouseEvent) => void, when?: boolean): [CallbackRef];

/**
 * usePreviousDifferent hook for React
 * It returns the past value which was different from the current one.
 *
 * @param currentValue The value whose previously different value is to be tracked
 * @returns The previous value
 * @see https://rooks.vercel.app/docs/usePreviousDifferent
 */
declare function usePreviousDifferent<T>(currentValue: T): T | null;

/**
 * usePreviousImmediate hook for React
 *
 * @param currentValue The value whose previous value is to be tracked
 * @returns The previous value
 * @see https://rooks.vercel.app/docs/usePreviousImmediate
 */
declare function usePreviousImmediate<T>(currentValue: T): T | null;

/**
 * useQueueState
 * Manages a queue with react hooks.
 * @param initialList Initial value of the list
 * @returns The list and controls to modify the queue
 * @see https://rooks.vercel.app/docs/useQueueState
 */
declare function useQueueState<T>(initialList: T[]): [
    T[],
    {
        dequeue: () => T | undefined;
        enqueue: (item: T) => number;
        length: number;
        peek: () => T | undefined;
    }
];

/**
 *
 * useRaf
 * Uses a polyfilled version of requestAnimationFrame
 *
 * @param {Function} callback The callback function to be executed
 * @param {boolean} [isActive] The value which while true, keeps the raf running infinitely
 * @see https://rooks.vercel.app/docs/useRaf
 */
declare function useRaf(callback: (timeElapsed: number) => void, isActive: boolean): void;

/**
 *
 * useResizeObserverRef hook
 *
 * Returns a resize observer for a React Ref and fires a callback
 * https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
 *
 * @param {ResizeObserverCallback} callback Function that needs to be fired on resize
 * @param {ResizeObserverOptions} options An options object allowing you to set options for the observation
 * @returns {[CallbackRef]} callbackref
 * @see https://rooks.vercel.app/docs/useResizeObserverRef
 */
declare function useResizeObserverRef(callback: ResizeObserverCallback | undefined, options?: ResizeObserverOptions): [CallbackRef];

/**
 * useRenderCount
 * @description Get the render count of a component
 * @see {@link https://rooks.vercel.app/docs/useRenderCount}
 */
declare function useRenderCount(): number;

/**
 * useRefElement hook for React
 * Helps bridge gap between callback ref and state
 * Manages the element called with callback ref api using state variable
 * @returns {[RefElementOrNull, (element: HTMLElementOrNull) => void]}
 * @see https://rooks.vercel.app/docs/useRefElement
 */
declare function useRefElement<T>(): [
    (refElement: RefElementOrNull<T>) => void,
    RefElementOrNull<T>
];

declare type SelectHandler<T> = {
    index: number;
    item: T;
    setIndex: (newIndex: number) => void;
    setItem: (newItem: T) => void;
};
/**
 * useSelect hook
 * Helps easily select a value from a list of values
 *
 * @param list List of values to select a value from
 * @param {number} initialIndex Initial index which is selected
 * @returns handler
 * @see https://rooks.vercel.app/docs/useSelect
 */
declare function useSelect<T>(list: T[], initialIndex?: number): SelectHandler<T>;

declare type Selection<T> = [number, T];
declare type UseSelectableListReturnType<T> = [
    Selection<T>,
    {
        matchSelection: (parameters: OptionalIndexValue<T>) => boolean;
        toggleSelection: (parameters: OptionalIndexValue<T>) => () => void;
        updateSelection: (parameters: OptionalIndexValue<T>) => () => void;
    }
];
/**
 * useSelectableList
 * Easily select a single value from a list of values. very useful for radio buttons, select inputs  etc.
 *
 * @param list - The list of values to select from
 * @param initialIndex  - The index of the initial selection
 * @param allowUnselected
 * @see https://rooks.vercel.app/docs/useSelectableList
 */
declare function useSelectableList<T>(list?: T[], initialIndex?: number, allowUnselected?: boolean): UseSelectableListReturnType<T>;

declare type UseSessionstorateStateReturnValue<S> = [
    S,
    Dispatch<SetStateAction<S>>,
    () => void
];
/**
 * useSessionstorageState hook
 * Tracks a value within sessionStorage and updates it
 *
 * @param {string} key - Key of the sessionStorage object
 * @param {any} initialState - Default initial value
 * @returns {[any, Dispatch<SetStateAction<any>>, () => void]}
 * @see https://rooks.vercel.app/docs/useSessionstorageState
 */
declare function useSessionstorageState<S>(key: string, initialState?: S | (() => S)): UseSessionstorateStateReturnValue<S>;

declare type Add<T> = (...args: Parameters<Set<T>["add"]>) => void;
declare type Delete<T> = (...args: Parameters<Set<T>["delete"]>) => void;
declare type UseSetStateControls<T> = {
    add: Add<T>;
    delete: Delete<T>;
    clear: () => void;
};
declare type UseSetStateReturnValue<T> = [Set<T>, UseSetStateControls<T>];
/**
 * useSetState
 * @description Manage the state of a Set in React.
 * @param {Set<T>} initialSetValue The initial value of the set to manage.
 * @returns {UseSetStateReturnValue<T>} The state of the Set and the controls.
 * @see {@link https://rooks.vercel.app/docs/useSetState}
 * @example
 * import { useSetState } from "@/hooks/useSetState";
 * const [set, setControls] = useSetState(new Set());
 * setControls.add(1); // {1}
 * setControls.add(2); // {1, 2}
 * setControls.delete(1); // {2}
 * setControls.clear(); // {}
 *
 */
declare function useSetState<T>(initialSetValue: Set<T>): UseSetStateReturnValue<T>;

/**
 * useStackState
 * @description Manages a stack with react hooks.
 * @param initialList Initial value of the list
 * @returns The list and controls to modify the stack
 * @see https://rooks.vercel.app/docs/useStackState
 */
declare function useStackState<T>(initialList: T[]): [
    T[],
    {
        clear: () => void;
        isEmpty: () => boolean;
        length: number;
        peek: () => T | undefined;
        pop: () => T | undefined;
        push: (item: T) => number;
    },
    T[]
];

declare type UpdateValueOptions = {
    overwriteLastEntry?: boolean;
};
declare type UseTimeTravelStateControls<T> = {
    backLength: number;
    forwardLength: number;
    go: (step: number) => void;
    back: (step?: number) => void;
    forward: (step?: number) => void;
    reset: (newInitialValue?: T) => void;
    undo: (step?: number) => void;
    redo: (step?: number) => void;
    canUndo: boolean;
    canRedo: boolean;
};
declare type UpdateValue<T> = (val: T | ((prevValue: T) => T), options?: UpdateValueOptions) => void;
declare type UseTimeTravelStateReturnValue<T> = [
    value: T,
    setValue: UpdateValue<T>,
    controls: UseTimeTravelStateControls<T>
];
/**
 * useTimeTravelState
 * @description A hook that manages state which can undo and redo. A more powerful version of useUndoState hook.
 * @see {@link https://rooks.vercel.app/docs/useTimeTravelState}
 * @param initialValue The initial value of the state.
 * @returns {UseTimeTravelStateReturnValue}
 * @example
 * const [value, setValue, controls] = useTimeTravelState(0);
 * setValue(1);
 * setValue(2);
 * setValue(3);
 * controls.back(); // value === 2
 * controls.back(); // value === 1
 * controls.forward(); // value === 2
 * controls.forward(); // value === 3
 * controls.reset(); // value === 0
 * controls.reset(5); // value === 5
 * controls.back(2); // value === 3
 *
 * setValue(1);
 * setValue(2);
 * setValue(6, { overwriteLastEntry: true });
 * setValue(7, { overwriteLastEntry: true });
 *
 * controls.back(2); // value === 1
 *
 */
declare function useTimeTravelState<T>(initialValue: T): UseTimeTravelStateReturnValue<T>;

declare type Callback$1<T> = (...args: T[]) => void;
/**
 * useThrottle
 * Throttles a function with a timeout and ensures
 * that the callback function runs at most once in that duration
 *
 * @param callback The callback to throttle
 * @param timeout Throttle timeout
 * @returns [Callback, isReady] The throttled callback and if it is currently throttled
 * @see https://rooks.vercel.app/docs/useThrottle
 */
declare function useThrottle<T>(callback: Callback$1<T>, timeout?: number): [Callback$1<T>, boolean];

/**
 * A setTimeout hook that calls a callback after a timeout duration
 * when a condition is true
 *
 * @param callback The callback to be invoked after timeout
 * @param timeoutDelayMs Amount of time in ms after which to invoke
 * @param when The condition which when true, sets the timeout
 * @see https://rooks.vercel.app/docs/useTimeoutWhen
 */
declare function useTimeoutWhen(callback: () => void, timeoutDelayMs?: number, when?: boolean): void;

/**
 * Use toggle hook helps you easily toggle a value.
 *
 * @param initialValue Initial value of the toggle, which will be false if not provided.
 * @returns [value, setValue]
 * @see https://rooks.vercel.app/docs/useToggle
 * @example
 * const [boolean, toggle] = useToggle();
 * // value is false
 * // toggle() will change value to true.
 */
declare function useToggle<S = boolean>(initialValue?: boolean): [S, Dispatch<unknown>];
/**
 * Use toggle hook helps you easily toggle a value
 *
 * @param initialValue Initial value of the toggle, which will be false if not provided.
 * @param toggleFunction A toggle function. This allows for non boolean toggles
 * @example
 * const [value, toggle] = useToggle("on", _value => _value === "on" ? "off" : "on");
 * // value is "on"
 * // toggle() will change value to "off". Calling it again will change value to "on".
 */
declare function useToggle<S>(initialValue: S, toggleFunction?: Reducer<S, unknown>): [S, Dispatch<unknown>];
/**
 * Use toggle hook helps you easily toggle a value
 *
 * @param initialValue Initial value of the toggle, which will be false if not provided.
 * @param toggleFunction A toggle function. This allows for non boolean toggles
 * @example
 * const [value, toggle] = useToggle("on", _value => _value === "on" ? "off" : "on");
 * // value is "on"
 * // toggle() will change value to "off". Calling it again will change value to "on".
 */
declare function useToggle<S>(initialValue: S, toggleFunction: ReducerWithoutAction<S>): [S, DispatchWithoutAction];

/**
 * useUndoState hook
 * Drop in replacement for useState hook but with undo functionality.
 *
 * @typedef UndoStateOptions
 * @type {object}
 * @property {number} maxSize - Maximum number of states to keep in the undo stack.
 * @param {any} defaultValue - Default value to use for the state. This will be the first value in the undo stack.
 * @param {UseUndoStateOptions} options - Options for the undo state. Currently takes the maxSize option.
 * @returns {UseUndoStateReturnValue}
 * @see https://rooks.vercel.app/docs/useUndoState
 */
declare const useUndoState: <T>(defaultValue: Exclude<T, AnyFunction>, options?: UseUndoStateOptions) => UseUndoStateReturnValue<T>;

declare type Callback = () => void;
/**
 * useWillUnmount hook
 * Fires a callback just before component unmounts
 *
 * @param {Function} callback Callback to be called before unmount
 * @see https://rooks.vercel.app/docs/useWillUnmount
 */
declare function useWillUnmount(callback: Callback): void;

/**
 *  useWindowEventListener hook
 *
 *  A react hook to an event listener to the window
 *
 * @param {keyof WindowEventMap} eventName The event to track
 * @param {Function} callback The callback to be called on event
 * @param {ListenerOptions} listenerOptions The options to be passed to the event listener
 * @param {boolean} isLayoutEffect Should it use layout effect. Defaults to false
 * @returns {undefined}
 * @see https://rooks.vercel.app/docs/useWindowEventListener
 */
declare function useWindowEventListener(eventName: keyof WindowEventMap, callback: (...args: unknown[]) => void, listenerOptions?: ListenerOptions, isLayoutEffect?: boolean): void;

declare type ScrollPosition = {
    scrollX: Window["scrollX"];
    scrollY: Window["scrollY"];
};
/**
 *
 * useWindowScrollPosition hook
 * A React hook to get the scroll position of the window
 *
 * @returns an object containing scrollX and scrollY values
 * @see https://rooks.vercel.app/docs/useWindowScrollPosition
 */
declare function useWindowScrollPosition(): ScrollPosition;

declare type WindowDimensions = DeepNullable<Pick<Window, "innerHeight" | "innerWidth" | "outerHeight" | "outerWidth">>;
/**
 * useWindowSize hook
 * A hook that provides information of the dimensions of the window
 *
 * @returns Dimensions of the window
 * @see https://rooks.vercel.app/docs/useWindowSize
 */
declare function useWindowSize(): WindowDimensions;

export { useArrayState, useAsyncEffect, useBoundingclientrect, useBoundingclientrectRef, useCountdown, useCounter, useDebounce, useDebouncedValue, useDidMount, useDidUpdate, useDimensionsRef, useDocumentEventListener, useDocumentVisibilityState, useEffectOnceWhen, useEventListenerRef, useFocus, useFocusWithin, useForkRef, useFreshRef, useFreshTick, useFullscreen, useGeolocation, useGetIsMounted, useInViewRef, useInput, useIntersectionObserverRef, useIntervalWhen, useIsomorphicEffect, useKey, useKeyBindings, useKeyRef, useKeys, useLifecycleLogger, useLocalstorageState, useMapState, useMediaMatch, useMergeRefs, useMouse, useMultiSelectableList, useMutationObserver, useMutationObserverRef, useNavigatorLanguage, useOnWindowResize, useOnWindowScroll, useOnline, useOutsideClick, useOutsideClickRef, usePreviousDifferent, usePreviousImmediate, useQueueState, useRaf, useRefElement, useRenderCount, useResizeObserverRef, useSelect, useSelectableList, useSessionstorageState, useSetState, useStackState, useThrottle, useTimeTravelState, useTimeoutWhen, useToggle, useUndoState, useWillUnmount, useWindowEventListener, useWindowScrollPosition, useWindowSize };
